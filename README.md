# Отчет по Лабораторной работе №2. Интеграционное тестирование

Выполнила Ходакова Мария Александровна

ИСУ 409800

Группа K3323

tg: @m_inf

### 1. Выбор проекта

Для выполнения лабораторной работы я выбрала проект FastAPI-CRUD-Todo. В проекте есть несколько взаимосвязанных модулей, что позволяет удобно продемонстрировать интеграционное тестирование.

В проекте используется SQLite и библиотека SQLAlchemy, значит, есть интеграция:
API - бизнес-логика - база данных - ответ.

Приложение работает с сущностью “задача” (ToDo) и поддерживает CRUD: создание, чтение, обновление и удаление.

### 2. Анализ взаимодействий

**Ключевые точки интеграции:**

1. API - HTTP-слой - routers

(В файле routers/todo.py определены HTTP-эндпоинты (для создания, получения, обновления, удаления задач))

Клиент делает HTTP-запрос на endpoint, запрос попадает в FastAPI-приложение, попадает в соответствующий роутер.

2. Router - Схемы данных (валидация и сериализация) - Pydantic-схемы

В проекте есть файл schemas.py, в котором описаны Pydantic-модели для входящих и исходящих данных. 

При получении запроса API данные валидируются спо схемам, при отдаче ответа сериализуются в нужный формат.

3. Схемы - ORM-модели - SQLAlchemy
  
   (модель - база данных)

В файле models.py описаны SQLAlchemy-модели, которые соответствуют структуре таблицы в базе данных.

Когда приходит запрос (после валидации), роутер / бизнес-логика создают/модифицируют/удаляют ORM-объекты - SQLAlchemy взаимодействует с SQLite: делает INSERT, UPDATE, DELETE, SELECT и т. д. Через сессию.

4. Database setup & connection (инициализация и сессии) - ORM - API

В файле database.py есть конфигурация подключения к SQLite, создание сессии, управление соединением с БД.

При обращении через API: получение сессии, выполнение операции через ORM, commit, возврат результата, сериализация и возврат клиенту.

**Критические части системы **

База данных (SQLite + SQLAlchemy-модели + сессии). Если неправильно настроено подключение, или неправильно описаны модели/схемы, то операции будут давать ошибку.

Схемы. Если входящие данные не соответствуют Pydantic-схемам, запросы будут отвергаться до обращения к БД.

routers (эндпоинты). Если маршрутизация или логика обработки запросов будет неправильной, API просто не будет работать или будет работать неверно.

Согласованность между схемами, моделями и API. Запросы, ORM-модели и схемы должны быть корректными по структуре данных, иначе интеграция даст сбой.

Обработка сессий и транзакций. Нужно корректно открывать/закрывать сессии, коммитить изменения, обрабатывать ошибки, иначе могут появиться утечки, несогласованности, неверные данные.

**Основные сценарии взаимодействия**

1. Создание новой задачи — API POST, база данных, возврат результата

Клиент отправляет POST запрос на endpoint создания задачи. Данные проходят валидацию (Pydantic), затем попадают в ORM-модель, сохраняются в базу (SQLite). Возвращается JSON-ответ с подробностями созданной задачи (id, текст, статус и тд).

2. Получение списка задач — API GET, DB SELECT, возврат списка

Клиент отправляет GET запрос на endpoint получить все задачи. ORM извлекает все записи из БД, сериализует их через схемы и возвращает JSON-массив задач.

3. Чтение задачи по id — API GET, DB SELECT, возврат результата

Клиент запрашивает задачу по конкретному id. ORM ищет запись, возвращает её, схема сериализует, клиент получает JSON.
Если задачи с таким id нет, то возвращается ошибка.

4. Обновление задачи — API PUT/PATCH, валидация, ORM, commit, возврат обновленной задачи

Клиент отправляет запрос на изменение полей задачи. Данные валидируются, ORM-модель обновляется, изменения сохраняются в бд, возвращается обновлённый объект.

5. Удаление задачи — API DELETE, ORM delete, commit, подтверждение удаления

Клиент делает DELETE запрос на удаление задачи по id. ORM удаляет запись из БД, коммит. Успех или ошибка, если задача не найдена.

6. Граничные сценарии

Попытка создать задачу с некорректными данными, ожидание ошибки валидации, и то, что в бд ничего не появилось.

Запрос к несуществующему id, ожидание корректного ответа и отсутствие данных.
